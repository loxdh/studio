/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model
 * for an e-commerce platform. The core principle is that all content (products,
 * categories, blog articles) is publicly readable by anyone, but can only be
 * created, modified, or deleted by authenticated users who have an "admin" role.
 *
 * Data Structure: The data is organized into flat, top-level collections for
 * `products`, `categories`, and `blog_articles`. A dedicated `/roles_admin`
 * collection is used to manage authorization.
 *
 * Key Security Decisions:
 * - Public Read-Only Access: All primary content collections are open for read
 *   and list operations to support anonymous browsing of the e-commerce site.
 * - Admin-Guarded Writes: All write operations (`create`, `update`, `delete`)
 *   on content collections are strictly limited to admin users.
 * - Role-Based Authorization: A user is considered an admin if a document with
 *   their UID exists in the `/roles_admin` collection. This avoids costly lookups
 *   and keeps authorization logic simple and performant.
 * - Admin Management: The `/roles_admin` collection itself is protected,
 *   allowing only existing admins to view or manage the list of other admins.
 *   This prevents unauthorized privilege escalation. Initial admin users must be
 *   added via the Firebase Console or a trusted backend script.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * An admin is defined by the existence of a document in the /roles_admin
     * collection where the document ID matches the user's UID.
     * This check is fast and efficient as it only verifies existence.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures that a state-changing operation (update, delete) is being
     * performed on a document that actually exists.
     */
    function isExistingDoc() {
      return resource != null;
/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model
 * for an e-commerce platform. The core principle is that all content (products,
 * categories, blog articles) is publicly readable by anyone, but can only be
 * created, modified, or deleted by authenticated users who have an "admin" role.
 *
 * Data Structure: The data is organized into flat, top-level collections for
 * `products`, `categories`, and `blog_articles`. A dedicated `/roles_admin`
 * collection is used to manage authorization.
 *
 * Key Security Decisions:
 * - Public Read-Only Access: All primary content collections are open for read
 *   and list operations to support anonymous browsing of the e-commerce site.
 * - Admin-Guarded Writes: All write operations (`create`, `update`, `delete`)
 *   on content collections are strictly limited to admin users.
 * - Role-Based Authorization: A user is considered an admin if a document with
 *   their UID exists in the `/roles_admin` collection. This avoids costly lookups
 *   and keeps authorization logic simple and performant.
 * - Admin Management: The `/roles_admin` collection itself is protected,
 *   allowing only existing admins to view or manage the list of other admins.
 *   This prevents unauthorized privilege escalation. Initial admin users must be
 *   added via the Firebase Console or a trusted backend script.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * An admin is defined by the existence of a document in the /roles_admin
     * collection where the document ID matches the user's UID.
     * This check is fast and efficient as it only verifies existence.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures that a state-changing operation (update, delete) is being
     * performed on a document that actually exists.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to the products collection.
     *   Products are publicly visible to all users, but only admins can
     *   create, update, or delete them.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Controls access to the categories collection.
     *   Categories are publicly visible, allowing users to browse products by
     *   category, but only admins can manage the category list.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Controls access to the blog articles collection.
     *   Blog articles are public content for all site visitors. Write access
     *   is restricted to admins for content management.
     */
    match /blog_articles/{blogArticleId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Secures the admin role management collection.
     *   This collection is the source of truth for admin privileges. Only
     *   existing admins are allowed to see who the other admins are or to
     *   grant/revoke admin status.
     */
    match /roles_admin/{userId} {
      allow get: if true; // Temporarily allowed
      allow list: if true; // Temporarily allowed
      allow create: if true; // Temporarily allowed
      allow update: if true; // Temporarily allowed
      allow delete: if true; // Temporarily allowed
    }

    /**
     * @description Controls access to the users collection.
     *   Users can read and write their own user document.
     */
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    /**
     * @description Controls access to the quotes collection.
     *   Users can create quotes and read their own.
     *   Admins can read all quotes.
     */
    match /quotes/{quoteId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow read: if true; // Temporarily allowed for admin view
      allow update, delete: if true; // Temporarily allowed for admin view
    }

    /**
     * @description Controls access to the files subcollection.
     *   Users can read and write their own files metadata.
     */
    match /users/{userId}/files/{fileId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model
 * for an e-commerce platform. The core principle is that all content (products,
 * categories, blog articles) is publicly readable by anyone, but can only be
 * created, modified, or deleted by authenticated users who have an "admin" role.
 *
 * Data Structure: The data is organized into flat, top-level collections for
 * `products`, `categories`, and `blog_articles`. A dedicated `/roles_admin`
 * collection is used to manage authorization.
 *
 * Key Security Decisions:
 * - Public Read-Only Access: All primary content collections are open for read
 *   and list operations to support anonymous browsing of the e-commerce site.
 * - Admin-Guarded Writes: All write operations (`create`, `update`, `delete`)
 *   on content collections are strictly limited to admin users.
 * - Role-Based Authorization: A user is considered an admin if a document with
 *   their UID exists in the `/roles_admin` collection. This avoids costly lookups
 *   and keeps authorization logic simple and performant.
 * - Admin Management: The `/roles_admin` collection itself is protected,
 *   allowing only existing admins to view or manage the list of other admins.
 *   This prevents unauthorized privilege escalation. Initial admin users must be
 *   added via the Firebase Console or a trusted backend script.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * An admin is defined by the existence of a document in the /roles_admin
     * collection where the document ID matches the user's UID.
     * This check is fast and efficient as it only verifies existence.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures that a state-changing operation (update, delete) is being
     * performed on a document that actually exists.
     */
    function isExistingDoc() {
      return resource != null;
/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model
 * for an e-commerce platform. The core principle is that all content (products,
 * categories, blog articles) is publicly readable by anyone, but can only be
 * created, modified, or deleted by authenticated users who have an "admin" role.
 *
 * Data Structure: The data is organized into flat, top-level collections for
 * `products`, `categories`, and `blog_articles`. A dedicated `/roles_admin`
 * collection is used to manage authorization.
 *
 * Key Security Decisions:
 * - Public Read-Only Access: All primary content collections are open for read
 *   and list operations to support anonymous browsing of the e-commerce site.
 * - Admin-Guarded Writes: All write operations (`create`, `update`, `delete`)
 *   on content collections are strictly limited to admin users.
 * - Role-Based Authorization: A user is considered an admin if a document with
 *   their UID exists in the `/roles_admin` collection. This avoids costly lookups
 *   and keeps authorization logic simple and performant.
 * - Admin Management: The `/roles_admin` collection itself is protected,
 *   allowing only existing admins to view or manage the list of other admins.
 *   This prevents unauthorized privilege escalation. Initial admin users must be
 *   added via the Firebase Console or a trusted backend script.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * An admin is defined by the existence of a document in the /roles_admin
     * collection where the document ID matches the user's UID.
     * This check is fast and efficient as it only verifies existence.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures that a state-changing operation (update, delete) is being
     * performed on a document that actually exists.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to the products collection.
     *   Products are publicly visible to all users, but only admins can
     *   create, update, or delete them.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Controls access to the categories collection.
     *   Categories are publicly visible, allowing users to browse products by
     *   category, but only admins can manage the category list.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Controls access to the blog articles collection.
     *   Blog articles are public content for all site visitors. Write access
     *   is restricted to admins for content management.
     */
    match /blog_articles/{blogArticleId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // Temporarily allowed for Firebase Studio
      allow update: if true; // Temporarily allowed for Firebase Studio
      allow delete: if true; // Temporarily allowed for Firebase Studio
    }

    /**
     * @description Secures the admin role management collection.
     *   This collection is the source of truth for admin privileges. Only
     *   existing admins are allowed to see who the other admins are or to
     *   grant/revoke admin status.
     */
    match /roles_admin/{userId} {
      allow get: if true; // Temporarily allowed
      allow list: if true; // Temporarily allowed
      allow create: if true; // Temporarily allowed
      allow update: if true; // Temporarily allowed
      allow delete: if true; // Temporarily allowed
    }

    /**
     * @description Controls access to the users collection.
     *   Users can read and write their own user document.
     */
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    /**
     * @description Controls access to the quotes collection.
     *   Users can create quotes and read their own.
     *   Admins can read all quotes.
     */
    match /quotes/{quoteId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow read: if true; // Temporarily allowed for admin view
      allow update, delete: if true; // Temporarily allowed for admin view
    }

    /**
     * @description Controls access to the files subcollection.
     *   Users can read and write their own files metadata.
     */
    match /users/{userId}/files/{fileId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    /**
     * @description Controls access to the orders collection.
     *   Users can create orders and read their own orders.
     *   Admins can read/write all orders.
     */
    match /orders/{orderId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow read: if true; // Temporarily allowed for admin view
      allow list: if true; // Temporarily allowed for admin view
      allow update, delete: if true; // Temporarily allowed for admin view
    }
  }
}